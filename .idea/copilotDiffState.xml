<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    id(&quot;com.google.gms.google-services&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.maswadkar.developers.androidify&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.maswadkar.developers.androidify&quot;&#10;        minSdk = 29&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.activity)&#10;    implementation(libs.androidx.constraintlayout)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    implementation(platform(&quot;com.google.firebase:firebase-bom:34.6.0&quot;))&#10;    implementation(&quot;com.google.firebase:firebase-ai:17.6.0&quot;)&#10;    implementation(&quot;io.noties.markwon:core:4.6.2&quot;)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    id(&quot;kotlin-parcelize&quot;)&#10;    id(&quot;com.google.gms.google-services&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.maswadkar.developers.androidify&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.maswadkar.developers.androidify&quot;&#10;        minSdk = 29&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.activity)&#10;    implementation(libs.androidx.constraintlayout)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    implementation(platform(&quot;com.google.firebase:firebase-bom:34.6.0&quot;))&#10;    implementation(&quot;com.google.firebase:firebase-ai:17.6.0&quot;)&#10;    implementation(&quot;io.noties.markwon:core:4.6.2&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.8.7&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:2.8.7&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/maswadkar/developers/androidify/ChatAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/maswadkar/developers/androidify/ChatAdapter.kt" />
              <option name="originalContent" value="package com.maswadkar.developers.androidify&#10;&#10;import android.content.Context&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.RecyclerView&#10;import io.noties.markwon.Markwon&#10;&#10;class ChatAdapter(private val messages: List&lt;ChatMessage&gt;) :&#10;    RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() {&#10;&#10;    private lateinit var markwon: Markwon&#10;&#10;    companion object {&#10;        private const val VIEW_TYPE_USER = 1&#10;        private const val VIEW_TYPE_MODEL = 2&#10;    }&#10;&#10;    override fun getItemViewType(position: Int): Int {&#10;        return if (messages[position].isUser) VIEW_TYPE_USER else VIEW_TYPE_MODEL&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {&#10;        if (!::markwon.isInitialized) {&#10;            markwon = Markwon.create(parent.context)&#10;        }&#10;        val inflater = LayoutInflater.from(parent.context)&#10;        return if (viewType == VIEW_TYPE_USER) {&#10;            val view = inflater.inflate(R.layout.item_message_user, parent, false)&#10;            UserMessageViewHolder(view)&#10;        } else {&#10;            val view = inflater.inflate(R.layout.item_message_model, parent, false)&#10;            ModelMessageViewHolder(view, markwon)&#10;        }&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {&#10;        val message = messages[position]&#10;        if (holder is UserMessageViewHolder) {&#10;            holder.bind(message)&#10;        } else if (holder is ModelMessageViewHolder) {&#10;            holder.bind(message)&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = messages.size&#10;&#10;    class UserMessageViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val tvUserMessage: TextView = itemView.findViewById(R.id.tvUserMessage)&#10;        fun bind(message: ChatMessage) {&#10;            tvUserMessage.text = message.text&#10;        }&#10;    }&#10;&#10;    class ModelMessageViewHolder(itemView: View, private val markwon: Markwon) : RecyclerView.ViewHolder(itemView) {&#10;        private val tvModelMessage: TextView = itemView.findViewById(R.id.tvModelMessage)&#10;        fun bind(message: ChatMessage) {&#10;            markwon.setMarkdown(tvModelMessage, message.text)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.maswadkar.developers.androidify&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.RecyclerView&#10;import io.noties.markwon.Markwon&#10;&#10;class ChatAdapter(private var messages: MutableList&lt;ChatMessage&gt;) :&#10;    RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() {&#10;&#10;    private lateinit var markwon: Markwon&#10;&#10;    companion object {&#10;        private const val VIEW_TYPE_USER = 1&#10;        private const val VIEW_TYPE_MODEL = 2&#10;    }&#10;&#10;    fun updateMessages(newMessages: List&lt;ChatMessage&gt;) {&#10;        val diffCallback = MessageDiffCallback(messages, newMessages)&#10;        val diffResult = DiffUtil.calculateDiff(diffCallback)&#10;        messages.clear()&#10;        messages.addAll(newMessages)&#10;        diffResult.dispatchUpdatesTo(this)&#10;    }&#10;&#10;    override fun getItemViewType(position: Int): Int {&#10;        return if (messages[position].isUser) VIEW_TYPE_USER else VIEW_TYPE_MODEL&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {&#10;        if (!::markwon.isInitialized) {&#10;            markwon = Markwon.create(parent.context)&#10;        }&#10;        val inflater = LayoutInflater.from(parent.context)&#10;        return if (viewType == VIEW_TYPE_USER) {&#10;            val view = inflater.inflate(R.layout.item_message_user, parent, false)&#10;            UserMessageViewHolder(view)&#10;        } else {&#10;            val view = inflater.inflate(R.layout.item_message_model, parent, false)&#10;            ModelMessageViewHolder(view, markwon)&#10;        }&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {&#10;        val message = messages[position]&#10;        if (holder is UserMessageViewHolder) {&#10;            holder.bind(message)&#10;        } else if (holder is ModelMessageViewHolder) {&#10;            holder.bind(message)&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = messages.size&#10;&#10;    class UserMessageViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        private val tvUserMessage: TextView = itemView.findViewById(R.id.tvUserMessage)&#10;        fun bind(message: ChatMessage) {&#10;            tvUserMessage.text = message.text&#10;        }&#10;    }&#10;&#10;    class ModelMessageViewHolder(itemView: View, private val markwon: Markwon) : RecyclerView.ViewHolder(itemView) {&#10;        private val tvModelMessage: TextView = itemView.findViewById(R.id.tvModelMessage)&#10;        fun bind(message: ChatMessage) {&#10;            markwon.setMarkdown(tvModelMessage, message.text)&#10;        }&#10;    }&#10;&#10;    private class MessageDiffCallback(&#10;        private val oldList: List&lt;ChatMessage&gt;,&#10;        private val newList: List&lt;ChatMessage&gt;&#10;    ) : DiffUtil.Callback() {&#10;        override fun getOldListSize(): Int = oldList.size&#10;        override fun getNewListSize(): Int = newList.size&#10;&#10;        override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {&#10;            // Messages at the same position are considered the same item&#10;            return oldItemPosition == newItemPosition&#10;        }&#10;&#10;        override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {&#10;            val oldItem = oldList[oldItemPosition]&#10;            val newItem = newList[newItemPosition]&#10;            return oldItem.text == newItem.text &amp;&amp; &#10;                   oldItem.isUser == newItem.isUser &amp;&amp; &#10;                   oldItem.isLoading == newItem.isLoading&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/maswadkar/developers/androidify/ChatMessage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/maswadkar/developers/androidify/ChatMessage.kt" />
              <option name="originalContent" value="package com.maswadkar.developers.androidify&#10;&#10;data class ChatMessage(&#10;    var text: String,&#10;    val isUser: Boolean,&#10;    val isLoading: Boolean = false&#10;)" />
              <option name="updatedContent" value="package com.maswadkar.developers.androidify&#10;&#10;import android.os.Parcelable&#10;import kotlinx.parcelize.Parcelize&#10;&#10;@Parcelize&#10;data class ChatMessage(&#10;    var text: String,&#10;    val isUser: Boolean,&#10;    var isLoading: Boolean = false&#10;) : Parcelable" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/maswadkar/developers/androidify/ChatViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/maswadkar/developers/androidify/ChatViewModel.kt" />
              <option name="updatedContent" value="package com.maswadkar.developers.androidify&#10;&#10;import androidx.lifecycle.SavedStateHandle&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.Firebase&#10;import com.google.firebase.ai.ai&#10;import com.google.firebase.ai.type.GenerativeBackend&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;&#10;class ChatViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {&#10;&#10;    companion object {&#10;        private const val MESSAGES_KEY = &quot;chat_messages&quot;&#10;        private const val MAX_MESSAGES = 100&#10;    }&#10;&#10;    private val funnyLoadingMessages = listOf(&#10;        &quot;Thinking... &quot;,&#10;        &quot;Consulting the matrix... &quot;,&#10;        &quot;Reticulating splines... ⚙️&quot;,&#10;        &quot;Asking the squirrels... ️&quot;,&#10;        &quot;Decoding the cosmos... &quot;,&#10;        &quot;Brewing some coffee... ☕&quot;,&#10;        &quot;Waking up the hamsters... &quot;,&#10;        &quot;Connecting to the neural net... &quot;,&#10;        &quot;Looking up the answer in a really big book... &quot;,&#10;        &quot;Asking the magic 8-ball... &quot;&#10;    )&#10;&#10;    private val _messages = MutableStateFlow&lt;List&lt;ChatMessage&gt;&gt;(&#10;        savedStateHandle.get&lt;ArrayList&lt;ChatMessage&gt;&gt;(MESSAGES_KEY) ?: emptyList()&#10;    )&#10;    val messages: StateFlow&lt;List&lt;ChatMessage&gt;&gt; = _messages.asStateFlow()&#10;&#10;    private val model = Firebase.ai(backend = GenerativeBackend.vertexAI())&#10;        .generativeModel(&quot;gemini-2.5-flash&quot;)&#10;&#10;    private var currentRequestJob: Job? = null&#10;&#10;    init {&#10;        // Clean up any loading messages from previous session (process death scenario)&#10;        val cleanedMessages = _messages.value.map { msg -&gt;&#10;            if (msg.isLoading) msg.copy(text = &quot;Request interrupted. Please try again.&quot;, isLoading = false)&#10;            else msg&#10;        }&#10;        if (cleanedMessages != _messages.value) {&#10;            updateMessages(cleanedMessages)&#10;        }&#10;    }&#10;&#10;    private fun updateMessages(newMessages: List&lt;ChatMessage&gt;) {&#10;        // Limit messages to prevent memory issues&#10;        val limitedMessages = if (newMessages.size &gt; MAX_MESSAGES) {&#10;            newMessages.takeLast(MAX_MESSAGES)&#10;        } else {&#10;            newMessages&#10;        }&#10;        _messages.value = limitedMessages&#10;        savedStateHandle[MESSAGES_KEY] = ArrayList(limitedMessages)&#10;    }&#10;&#10;    fun sendMessage(userText: String) {&#10;        if (userText.isBlank()) return&#10;&#10;        // Add user message&#10;        val userMessage = ChatMessage(userText, isUser = true)&#10;        val currentMessages = _messages.value.toMutableList()&#10;        currentMessages.add(userMessage)&#10;&#10;        // Add loading message&#10;        val loadingMessage = ChatMessage(funnyLoadingMessages.first(), isUser = false, isLoading = true)&#10;        currentMessages.add(loadingMessage)&#10;        updateMessages(currentMessages)&#10;&#10;        val loadingIndex = _messages.value.size - 1&#10;&#10;        // Cancel any existing request&#10;        currentRequestJob?.cancel()&#10;&#10;        currentRequestJob = viewModelScope.launch {&#10;            val animationJob = launch {&#10;                while (isActive) {&#10;                    delay(5000)&#10;                    val updatedMessages = _messages.value.toMutableList()&#10;                    if (loadingIndex &lt; updatedMessages.size &amp;&amp; updatedMessages[loadingIndex].isLoading) {&#10;                        updatedMessages[loadingIndex] = updatedMessages[loadingIndex].copy(&#10;                            text = funnyLoadingMessages.random()&#10;                        )&#10;                        updateMessages(updatedMessages)&#10;                    }&#10;                }&#10;            }&#10;&#10;            try {&#10;                val response = model.generateContent(userText)&#10;                val modelText = response.text ?: &quot;No response&quot;&#10;&#10;                animationJob.cancel()&#10;&#10;                // Update loading message with real response&#10;                val updatedMessages = _messages.value.toMutableList()&#10;                if (loadingIndex &lt; updatedMessages.size) {&#10;                    updatedMessages[loadingIndex] = updatedMessages[loadingIndex].copy(&#10;                        text = modelText,&#10;                        isLoading = false&#10;                    )&#10;                    updateMessages(updatedMessages)&#10;                }&#10;            } catch (e: Exception) {&#10;                animationJob.cancel()&#10;                val updatedMessages = _messages.value.toMutableList()&#10;                if (loadingIndex &lt; updatedMessages.size) {&#10;                    updatedMessages[loadingIndex] = updatedMessages[loadingIndex].copy(&#10;                        text = &quot;Error: ${e.message}&quot;,&#10;                        isLoading = false&#10;                    )&#10;                    updateMessages(updatedMessages)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/maswadkar/developers/androidify/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/maswadkar/developers/androidify/MainActivity.kt" />
              <option name="originalContent" value="package com.maswadkar.developers.androidify&#10;&#10;import android.os.Bundle&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.google.firebase.Firebase&#10;import com.google.firebase.ai.ai&#10;import com.google.firebase.ai.type.GenerativeBackend&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private val messages = mutableListOf&lt;ChatMessage&gt;()&#10;    private lateinit var chatAdapter: ChatAdapter&#10;    &#10;    private val funnyLoadingMessages = listOf(&#10;        &quot;Thinking... &quot;,&#10;        &quot;Consulting the matrix... &quot;,&#10;        &quot;Reticulating splines... ⚙️&quot;,&#10;        &quot;Asking the squirrels... ️&quot;,&#10;        &quot;Decoding the cosmos... &quot;,&#10;        &quot;Brewing some coffee... ☕&quot;,&#10;        &quot;Waking up the hamsters... &quot;,&#10;        &quot;Connecting to the neural net... &quot;,&#10;        &quot;Looking up the answer in a really big book... &quot;,&#10;        &quot;Asking the magic 8-ball... &quot;&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_main)&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val imeInsets = insets.getInsets(WindowInsetsCompat.Type.ime() or WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(imeInsets.left, imeInsets.top, imeInsets.right, imeInsets.bottom)&#10;            insets&#10;        }&#10;&#10;        val rvChat = findViewById&lt;RecyclerView&gt;(R.id.rvChat)&#10;        val etInput = findViewById&lt;EditText&gt;(R.id.etInput)&#10;        val btnSend = findViewById&lt;Button&gt;(R.id.btnSend)&#10;&#10;        chatAdapter = ChatAdapter(messages)&#10;        rvChat.layoutManager = LinearLayoutManager(this).apply {&#10;            stackFromEnd = true // Start from bottom like a chat&#10;        }&#10;        rvChat.adapter = chatAdapter&#10;&#10;        // Initialize Firebase AI with Gemini model&#10;        val model = Firebase.ai(backend = GenerativeBackend.vertexAI())&#10;            .generativeModel(&quot;gemini-2.5-flash&quot;)&#10;&#10;        btnSend.setOnClickListener {&#10;            val userText = etInput.text.toString().trim()&#10;            if (userText.isNotEmpty()) {&#10;                // Add user message&#10;                messages.add(ChatMessage(userText, true))&#10;                chatAdapter.notifyItemInserted(messages.size - 1)&#10;                rvChat.scrollToPosition(messages.size - 1)&#10;                etInput.text.clear()&#10;&#10;                // Add placeholder loading message&#10;                val loadingMessage = ChatMessage(funnyLoadingMessages.first(), false, true)&#10;                messages.add(loadingMessage)&#10;                val loadingIndex = messages.size - 1&#10;                chatAdapter.notifyItemInserted(loadingIndex)&#10;                rvChat.scrollToPosition(loadingIndex)&#10;&#10;                // Call AI&#10;                lifecycleScope.launch {&#10;                    val animationJob = launch {&#10;                        while (isActive) {&#10;                            delay(5000)&#10;                            loadingMessage.text = funnyLoadingMessages.random()&#10;                            chatAdapter.notifyItemChanged(loadingIndex)&#10;                        }&#10;                    }&#10;&#10;                    try {&#10;                        val response = model.generateContent(userText)&#10;                        val modelText = response.text ?: &quot;No response&quot;&#10;                        &#10;                        animationJob.cancel()&#10;                        &#10;                        // Update loading message with real response&#10;                        loadingMessage.text = modelText&#10;                        chatAdapter.notifyItemChanged(loadingIndex)&#10;                        rvChat.scrollToPosition(loadingIndex)&#10;                    } catch (e: Exception) {&#10;                        animationJob.cancel()&#10;                        loadingMessage.text = &quot;Error: ${e.message}&quot;&#10;                        chatAdapter.notifyItemChanged(loadingIndex)&#10;                        rvChat.scrollToPosition(loadingIndex)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.maswadkar.developers.androidify&#10;&#10;import android.os.Bundle&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.viewModels&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.lifecycle.repeatOnLifecycle&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : AppCompatActivity() {&#10;&#10;    private val viewModel: ChatViewModel by viewModels()&#10;    private lateinit var chatAdapter: ChatAdapter&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContentView(R.layout.activity_main)&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val imeInsets = insets.getInsets(WindowInsetsCompat.Type.ime() or WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(imeInsets.left, imeInsets.top, imeInsets.right, imeInsets.bottom)&#10;            insets&#10;        }&#10;&#10;        val rvChat = findViewById&lt;RecyclerView&gt;(R.id.rvChat)&#10;        val etInput = findViewById&lt;EditText&gt;(R.id.etInput)&#10;        val btnSend = findViewById&lt;Button&gt;(R.id.btnSend)&#10;&#10;        chatAdapter = ChatAdapter(mutableListOf())&#10;        rvChat.layoutManager = LinearLayoutManager(this).apply {&#10;            stackFromEnd = true // Start from bottom like a chat&#10;        }&#10;        rvChat.adapter = chatAdapter&#10;&#10;        // Observe messages from ViewModel&#10;        lifecycleScope.launch {&#10;            repeatOnLifecycle(Lifecycle.State.STARTED) {&#10;                viewModel.messages.collect { messages -&gt;&#10;                    chatAdapter.updateMessages(messages)&#10;                    if (messages.isNotEmpty()) {&#10;                        rvChat.scrollToPosition(messages.size - 1)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        btnSend.setOnClickListener {&#10;            val userText = etInput.text.toString().trim()&#10;            if (userText.isNotEmpty()) {&#10;                viewModel.sendMessage(userText)&#10;                etInput.text.clear()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>